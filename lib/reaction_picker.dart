import 'package:flutter/material.dart';

/// Flutter icons ReactionIcons
/// Copyright (C) 2020 by original authors @ fluttericon.com, fontello.com
/// This font was generated by FlutterIcon.com, which is derived from Fontello.
///
/// To use this font, place it in your fonts/ directory and include the
/// following in your pubspec.yaml
///
/// flutter:
///   fonts:
///    - family:  ReactionIcons
///      fonts:
///       - asset: fonts/ReactionIcons.ttf
///
///
/// * Font Awesome 5, Copyright (C) 2016 by Dave Gandy
///         Author:    Dave Gandy
///         License:   SIL (https://github.com/FortAwesome/Font-Awesome/blob/master/LICENSE.txt)
///         Homepage:  http://fortawesome.github.com/Font-Awesome/
///
import 'package:flutter/widgets.dart';

class ReactionIcons {
  ReactionIcons._();

  static const _kFontFam = 'ReactionIcons';
  static const _kFontPkg = null;

  static const IconData angry =
  IconData(0xf556, fontFamily: _kFontFam, fontPackage: _kFontPkg);
  static const IconData grin_beam_sweat =
  IconData(0xf583, fontFamily: _kFontFam, fontPackage: _kFontPkg);
  static const IconData grin_tongue_wink =
  IconData(0xf58b, fontFamily: _kFontFam, fontPackage: _kFontPkg);
  static const IconData kiss_wink_heart =
  IconData(0xf598, fontFamily: _kFontFam, fontPackage: _kFontPkg);
  static const IconData meh_rolling_eyes =
  IconData(0xf5a5, fontFamily: _kFontFam, fontPackage: _kFontPkg);
  static const IconData sad_tear =
  IconData(0xf5b4, fontFamily: _kFontFam, fontPackage: _kFontPkg);
  static const IconData smile_beam =
  IconData(0xf5b8, fontFamily: _kFontFam, fontPackage: _kFontPkg);
  static const IconData tired =
  IconData(0xf5c8, fontFamily: _kFontFam, fontPackage: _kFontPkg);
}

enum Reaction { angry, sweat, wink, heart, rollingEyes, sadTear, smile, tired }

class ReactionPicker extends StatefulWidget {
  final List<Reaction> reaction;
  final double iconSize;
  final ValueChanged<Reaction> onChanged;
  final int crossAxisCount;

  const ReactionPicker(
      {Key key,
        List<Reaction> only,
        this.iconSize = 24.0,
        this.onChanged,
        this.crossAxisCount = 4})
      : this.reaction = only ?? Reaction.values,
        super(key: key);

  @override
  _ReactionPickerState createState() => _ReactionPickerState();
}

class _ReactionPickerState extends State<ReactionPicker> {
  Reaction _reaction;

  @override
  Widget build(BuildContext context) {
    return GridView.count(
      crossAxisCount: widget.crossAxisCount,
      shrinkWrap: true,
      padding: const EdgeInsets.all(0),
      children: _buildReactionWidgets(),
    );
  }

  List<Widget> _buildReactionWidgets() {
    _onChanged(Reaction reaction) {
      if (reaction != null && widget.onChanged != null) {
        setState(() => _reaction = reaction);
        widget.onChanged(reaction);
      }
    }

    final widgets = <Widget>[];
    if (this.widget.reaction.contains(Reaction.angry)) {
      final iconButton = _CustomIconButton(
        size: widget.iconSize,
        color: Colors.red,
        reaction: Reaction.angry,
        isSelected: _reaction == Reaction.angry,
        icon: ReactionIcons.angry,
        onChanged: _onChanged,
      );
      widgets.add(iconButton);
    }
    if (this.widget.reaction.contains(Reaction.tired)) {
      final iconButton = _CustomIconButton(
        size: widget.iconSize,
        color: Colors.amber,
        reaction: Reaction.tired,
        isSelected: _reaction == Reaction.tired,
        icon: ReactionIcons.tired,
        onChanged: _onChanged,
      );
      widgets.add(iconButton);
    }

    if (this.widget.reaction.contains(Reaction.heart)) {
      final iconButton = _CustomIconButton(
        size: widget.iconSize,
        color: Colors.pink,
        reaction: Reaction.heart,
        isSelected: _reaction == Reaction.heart,
        icon: ReactionIcons.kiss_wink_heart,
        onChanged: _onChanged,
      );
      widgets.add(iconButton);
    }

    if (this.widget.reaction.contains(Reaction.rollingEyes)) {
      final iconButton = _CustomIconButton(
        size: widget.iconSize,
        color: Colors.lime,
        reaction: Reaction.rollingEyes,
        isSelected: _reaction == Reaction.rollingEyes,
        icon: ReactionIcons.meh_rolling_eyes,
        onChanged: _onChanged,
      );
      widgets.add(iconButton);
    }

    if (this.widget.reaction.contains(Reaction.sadTear)) {
      final iconButton = _CustomIconButton(
        size: widget.iconSize,
        color: Colors.lightBlueAccent,
        reaction: Reaction.sadTear,
        isSelected: _reaction == Reaction.sadTear,
        icon: ReactionIcons.sad_tear,
        onChanged: _onChanged,
      );
      widgets.add(iconButton);
    }

    if (this.widget.reaction.contains(Reaction.smile)) {
      final iconButton = _CustomIconButton(
        size: widget.iconSize,
        color: Colors.orange,
        reaction: Reaction.smile,
        isSelected: _reaction == Reaction.smile,
        icon: ReactionIcons.smile_beam,
        onChanged: _onChanged,
      );
      widgets.add(iconButton);
    }

    if (this.widget.reaction.contains(Reaction.sweat)) {
      final iconButton = _CustomIconButton(
        size: widget.iconSize,
        color: Colors.teal,
        reaction: Reaction.sweat,
        isSelected: _reaction == Reaction.sweat,
        icon: ReactionIcons.grin_beam_sweat,
        onChanged: _onChanged,
      );
      widgets.add(iconButton);
    }

    if (this.widget.reaction.contains(Reaction.wink)) {
      final iconButton = _CustomIconButton(
        size: widget.iconSize,
        color: Colors.purpleAccent,
        reaction: Reaction.wink,
        isSelected: _reaction == Reaction.wink,
        icon: ReactionIcons.grin_tongue_wink,
        onChanged: _onChanged,
      );
      widgets.add(iconButton);
    }

    return widgets;
  }
}

class _CustomIconButton extends StatelessWidget {
  final Color color;
  final double size;
  final Reaction reaction;
  final ValueChanged<Reaction> onChanged;
  final bool isSelected;
  final IconData icon;

  const _CustomIconButton(
      {Key key,
        this.color,
        this.size,
        this.reaction,
        this.onChanged,
        this.icon,
        this.isSelected})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ClipRRect(
      borderRadius: BorderRadius.circular(size),
      child: Container(
        color: isSelected ? color.withOpacity(0.2) : null,
        child: IconButton(
            highlightColor: color.withOpacity(0.3),
            splashColor: color.withOpacity(0.3),
            iconSize: size,
            icon: Icon(icon, size: size, color: color),
            onPressed: () => onChanged(reaction)),
      ),
    );
  }
}
